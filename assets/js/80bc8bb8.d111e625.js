"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[727],{49164:n=>{n.exports=JSON.parse('{"functions":[{"name":"new","desc":"Constructs a new Signal.","params":[{"name":"janitor?","desc":"Adds the Signal to the Janitor.","lua_type":"Janitor"}],"returns":[{"desc":"","lua_type":"Signal<Function, Arguments...>"}],"function_type":"static","source":{"line":261,"path":"src/init.luau"}},{"name":"Wrap","desc":"Constructs a new Signal that wraps around an RBXScriptSignal.\\n\\nFor example:\\n\\n```lua\\nlocal signal = Signal.Wrap(workspace.ChildAdded)\\nsignal:Connect(function(part) print(part.Name .. \\" added\\") end)\\nInstance.new(\\"Part\\").Parent = workspace\\n```","params":[{"name":"rbxScriptSignal","desc":"Existing RBXScriptSignal to wrap","lua_type":"RBXScriptSignal"},{"name":"janitor?","desc":"Adds the Signal to the Janitor.","lua_type":"Janitor"}],"returns":[{"desc":"","lua_type":"Signal"}],"function_type":"static","source":{"line":288,"path":"src/init.luau"}},{"name":"Is","desc":"Checks if the given value is a Signal.","params":[{"name":"value","desc":"Object to check.","lua_type":"unknown"}],"returns":[{"desc":"`true` if the value is a Signal.","lua_type":"boolean"}],"function_type":"static","source":{"line":308,"path":"src/init.luau"}},{"name":"instanceof","desc":"A shorthand for [Signal.Is].","params":[{"name":"value","desc":"Object to check.","lua_type":"unknown"}],"returns":[{"desc":"`true` if the value is a Signal.","lua_type":"boolean"}],"function_type":"static","source":{"line":321,"path":"src/init.luau"}},{"name":"Connect","desc":"Connects a function to the signal, which will be called anytime the signal\\nis fired.\\n\\n```lua\\nsignal:Connect(function(msg, num)\\n\\tprint(msg, num)\\nend)\\n\\nsignal:Fire(\\"Hello\\", 25)\\n```","params":[{"name":"callback","desc":"The function you are connecting.","lua_type":"(Arguments...) -> ()"}],"returns":[{"desc":"","lua_type":"Connection"}],"function_type":"method","source":{"line":341,"path":"src/init.luau"}},{"name":"ConnectOnce","desc":"","params":[{"name":"callback","desc":"The function you are connecting.","lua_type":"(Arguments...) -> ()"}],"returns":[{"desc":"","lua_type":"Connection"}],"function_type":"method","deprecated":{"version":"v1.3.0","desc":"Use `Signal:Once` instead."},"source":{"line":361,"path":"src/init.luau"}},{"name":"Once","desc":"Connects a function to the signal, which will be called the next time the signal fires. Once\\nthe connection is triggered, it will disconnect itself.\\n\\n```lua\\nsignal:Once(function(msg, num)\\n\\tprint(msg, num)\\nend)\\n\\nsignal:Fire(\\"Hello\\", 25)\\nsignal:Fire(\\"This message will not go through\\", 10)\\n```","params":[{"name":"callback","desc":"The function you are connecting.","lua_type":"(Arguments...) -> ()"}],"returns":[{"desc":"","lua_type":"Connection"}],"function_type":"method","source":{"line":381,"path":"src/init.luau"}},{"name":"ConnectClassic","desc":"The exact same as [Signal.Connect], but it returns an [RBXScriptConnection]\\ninstead.","params":[{"name":"callback","desc":"The function you are connecting.","lua_type":"(Arguments...) -> ()"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection"}],"function_type":"method","since":"v2.0.0","source":{"line":408,"path":"src/init.luau"}},{"name":"OnceClassic","desc":"The exact same as [Signal.Once], but it returns an [RBXScriptConnection]\\ninstead.","params":[{"name":"callback","desc":"The function you are connecting.","lua_type":"(Arguments...) -> ()"}],"returns":[{"desc":"","lua_type":"RBXScriptConnection"}],"function_type":"method","since":"v2.0.0","source":{"line":421,"path":"src/init.luau"}},{"name":"GetConnections","desc":"Gets all the connections in the signal.","params":[],"returns":[{"desc":"","lua_type":"{Connection}"}],"function_type":"method","source":{"line":431,"path":"src/init.luau"}},{"name":"IsConnectedTo","desc":"Checks if there are any active connections in the signal.","params":[],"returns":[{"desc":"","lua_type":"boolean"}],"function_type":"method","since":"v1.0.1","source":{"line":454,"path":"src/init.luau"}},{"name":"Fire","desc":"Fire the signal, which will call all of the connected functions with the\\ngiven arguments.\\n\\n```lua\\nsignal:Fire(\\"Hello\\")\\n\\n-- Any number of arguments can be fired:\\nsignal:Fire(\\"Hello\\", 32, {Test = \\"Test\\"}, true)\\n```","params":[{"name":"...","desc":"","lua_type":"Arguments..."}],"returns":[],"function_type":"method","source":{"line":478,"path":"src/init.luau"}},{"name":"FireDeferred","desc":"Same as [Signal.Fire], but uses `task.defer` internally & doesn\'t take\\nadvantage of thread reuse.\\n\\n```lua\\nsignal:FireDeferred(\\"Hello\\")\\n```","params":[{"name":"...","desc":"","lua_type":"Arguments..."}],"returns":[],"function_type":"method","source":{"line":506,"path":"src/init.luau"}},{"name":"FireDeferredUnsafe","desc":"An \\"unsafe\\" version of [Signal.FireDeferred] that uses recycled threads\\nto fire. Don\'t know if this will work the exact same, therefore it is\\nunsafe.","params":[{"name":"...","desc":"","lua_type":"Arguments..."}],"returns":[],"function_type":"method","since":"v2.0.0","source":{"line":525,"path":"src/init.luau"}},{"name":"Wait","desc":"Yields the current thread until the signal is fired, and returns the\\narguments fired from the signal. Yielding the current thread is not always\\ndesirable. If the desire is to only capture the next event fired, using\\n[Signal.Once] might be a better solution.\\n\\n```lua\\ntask.spawn(function()\\n\\tlocal msg, num = signal:Wait()\\n\\tprint(msg, num) --\x3e \\"Hello\\", 32\\nend)\\nsignal:Fire(\\"Hello\\", 32)\\n```","params":[],"returns":[{"desc":"","lua_type":"... Arguments..."}],"function_type":"method","yields":true,"source":{"line":550,"path":"src/init.luau"}},{"name":"DisconnectAll","desc":"Disconnect all handlers. Since we use a linked list it suffices to clear\\nthe reference to the head handler.\\n\\n```lua\\nsignal:DisconnectAll()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":578,"path":"src/init.luau"}},{"name":"Destroy","desc":"Cleans up the signal and renders it completely unusable.\\n\\n:::tip Cleanups\\nTechnically, this is only necessary if the signal is created using\\n[Signal.Wrap]. Connections should be properly GC\'d once the signal is no\\nlonger referenced anywhere. However, it is still good practice to include\\nways to strictly clean up resources. Calling [Signal.Destroy] on a signal\\nwill also disconnect all connections immediately.\\n:::\\n\\n```lua\\nsignal:Destroy()\\n```","params":[],"returns":[],"function_type":"method","source":{"line":606,"path":"src/init.luau"}}],"properties":[],"types":[{"name":"Connection","desc":"Represents a connection to a signal.\\n\\n```lua\\nlocal connection = signal:Connect(function() end)\\nprint(connection.Connected) --\x3e true\\nconnection:Disconnect()\\nprint(connection.Connected) --\x3e false\\n```","fields":[{"name":"Connected","lua_type":"boolean","desc":""},{"name":"Disconnect","lua_type":"(self: Connection) -> ()","desc":""}],"source":{"line":75,"path":"src/init.luau"}},{"name":"ConnectionFunction","desc":"A function connected to a signal.","lua_type":"(...any) -> ()","source":{"line":153,"path":"src/init.luau"}}],"name":"Signal","desc":"Signals allow events to be dispatched and handled.\\n\\nFor example:\\n\\n```lua\\nlocal signal = Signal.new()\\n\\nsignal:Connect(function(msg)\\n\\tprint(\\"Got message:\\", msg)\\nend)\\n\\nsignal:Fire(\\"Hello world!\\")\\n```","source":{"line":250,"path":"src/init.luau"}}')}}]);