[{"title":"Getting Started with BetterSignal","type":0,"sectionRef":"#","url":"/BetterSignal/docs/intro","content":"Getting Started with BetterSignal Here are some quick links to get started using BetterSignal: Installation guideAPI Docs","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"/BetterSignal/docs/installation","content":"","keywords":""},{"title":"Method #1 - RepoToRoblox​","type":1,"pageTitle":"Installation","url":"/BetterSignal/docs/installation#method-1---repotoroblox","content":"Using the RepoToRoblox plugin is the easiest way to install in Studio. In the RepoToRoblox widget, enter howmanysmall as the owner and better-signal as the repository.Click the Clone Repository button. "},{"title":"Method 2 - Wally​","type":1,"pageTitle":"Installation","url":"/BetterSignal/docs/installation#method-2---wally","content":"Setup Wally by using wally init.Add howmanysmall/better-signal as a dependency. [dependencies] Signal = &quot;howmanysmall/better-signal@2.0.3&quot;  "},{"title":"Signal","type":0,"sectionRef":"#","url":"/BetterSignal/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Connection","content":"&lt;/&gt; interface Connection { Connected: boolean Disconnect: (self: Connection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFunction​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#ConnectionFunction","content":"&lt;/&gt; type ConnectionFunction = (...any) → () A function connected to a signal. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#new","content":"&lt;/&gt; Signal.new( janitor?: Janitor-- Adds the Signal to the Janitor. ) → Signal&lt;Function,Arguments...&gt; Constructs a new Signal.  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal ,-- Existing RBXScriptSignal to wrap janitor?: Janitor-- Adds the Signal to the Janitor. ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Is","content":"&lt;/&gt; Signal.Is( value: unknown-- Object to check. ) → boolean-- true if the value is a Signal. Checks if the given value is a Signal.  "},{"title":"instanceof​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#instanceof","content":"&lt;/&gt; Signal.instanceof( value: unknown-- Object to check. ) → boolean-- true if the value is a Signal. A shorthand for Signal.Is.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect( callback: (Arguments...) → ()-- The function you are connecting. ) → Connection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Once","content":"&lt;/&gt; Signal:Once( callback: (Arguments...) → ()-- The function you are connecting. ) → Connection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"ConnectClassic​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#ConnectClassic","content":"since v2.0.0 &lt;/&gt; Signal:ConnectClassic( callback: (Arguments...) → ()-- The function you are connecting. ) → RBXScriptConnection  The exact same as Signal.Connect, but it returns an RBXScriptConnection instead.  "},{"title":"OnceClassic​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#OnceClassic","content":"since v2.0.0 &lt;/&gt; Signal:OnceClassic( callback: (Arguments...) → ()-- The function you are connecting. ) → RBXScriptConnection  The exact same as Signal.Once, but it returns an RBXScriptConnection instead.  "},{"title":"GetConnections​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#GetConnections","content":"&lt;/&gt; Signal:GetConnections() → {Connection} Gets all the connections in the signal.  "},{"title":"IsConnectedTo​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#IsConnectedTo","content":"since v1.0.1 &lt;/&gt; Signal:IsConnectedTo() → boolean Checks if there are any active connections in the signal.  "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: Arguments...) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: Arguments...) → () Same as Signal.Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"FireDeferredUnsafe​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#FireDeferredUnsafe","content":"since v2.0.0 &lt;/&gt; Signal:FireDeferredUnsafe(...: Arguments...) → () An &quot;unsafe&quot; version of Signal.FireDeferred that uses recycled threads to fire. Don't know if this will work the exact same, therefore it is unsafe.  "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...Arguments... Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, usingSignal.Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnect all handlers. Since we use a linked list it suffices to clear the reference to the head handler. signal:DisconnectAll()   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal and renders it completely unusable. Cleanups Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Signal.Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce( callback: (Arguments...) → ()-- The function you are connecting. ) → Connection  "}]