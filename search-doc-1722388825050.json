[{"title":"Getting Started with BetterSignal","type":0,"sectionRef":"#","url":"/BetterSignal/docs/intro","content":"Getting Started with BetterSignal Here are some quick links to get started using BetterSignal: Installation guideAPI Docs","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"/BetterSignal/docs/installation","content":"","keywords":""},{"title":"Method #1 - RepoToRoblox​","type":1,"pageTitle":"Installation","url":"/BetterSignal/docs/installation#method-1---repotoroblox","content":"Using the RepoToRoblox plugin is the easiest way to install in Studio. In the RepoToRoblox widget, enter howmanysmall as the owner and better-signal as the repository.Click the Clone Repository button. "},{"title":"Method 2 - Wally​","type":1,"pageTitle":"Installation","url":"/BetterSignal/docs/installation#method-2---wally","content":"Setup Wally by using wally init.Add howmanysmall/better-signal as a dependency. [dependencies] Signal = &quot;howmanysmall/better-signal@2.1.0&quot;  "},{"title":"Justification","type":0,"sectionRef":"#","url":"/BetterSignal/docs/justification","content":"","keywords":""},{"title":"Differences from sleitnick/signal​","type":1,"pageTitle":"Justification","url":"/BetterSignal/docs/justification#differences-from-sleitnicksignal","content":"I've added quite a few different things compared to the module this was based on. I'll list them here. --!native - My module is running in native mode. This does in fact make a difference for performance, even if it is a minor one.--!strict - I've retyped the entire thing so it works on strict mode.New features - I have actually added a lot of new features to the library. Connection.disconnect - Back when I was working at Ping/Crime Kitchen, a lot of things were using disconnect, so I added that for consistency reasons.Better types - I got really used to having the parameter names like how TypeScript would allow, so I added a Function parameter to the Signal type which allows you to specify it. It is unfortunately more work to do, but the ClassicSignal type does exist for this.Signal.IsConnectedTo - There was no way for me to check if something was connected to the signal, so I added this function. You probably won't need it though.Removed the unnecessary ultra strict metatables - I don't think this was necessary. It is a weird design choice.Signal.FireDeferredUnsafe - There was technically a way to make Signal.FireDeferred faster, so I implemented it as an unsafe function. Don't know if it's exactly the same, but it should be.Signal.FireBindable - Sometimes, you do want to replicate how a BindableEvent would behave in the current SignalBehavior mode, so I added this.Signal.FireBindableUnsafe - Same justification.Signal.DebugMode - I just really don't like unnecessary output logging in Signal.DisconnectAll, so I made this optional property to toggle it.Signal.Destroy - This actually sets the metatable to nil now. Consistent with all my other stuff.Signal.instanceof - Another holdover from TypeScript. Performance optimizations - I did optimize this a bit. Should be a bit faster than the original library, and maybe faster than the other Signal libraries. "},{"title":"Signal","type":0,"sectionRef":"#","url":"/BetterSignal/api/Signal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#types","content":" "},{"title":"Connection​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Connection","content":"&lt;/&gt; interface Connection { Connected: boolean Disconnect: (self: Connection) → () Destroy: (self: Connection) → () disconnect: (self: Connection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   "},{"title":"ConnectionFunction​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#ConnectionFunction","content":"&lt;/&gt; type ConnectionFunction = (...any) → () A function connected to a signal. "},{"title":"Properties​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#properties","content":" "},{"title":"DebugMode​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#DebugMode","content":"since v2.1.0 &lt;/&gt; Signal.DebugMode: boolean Whether or not to do a warning when a thread is suspended whenSignal.DisconnectAll is called. By default it is false. "},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#new","content":"&lt;/&gt; Signal.new( janitor?: Janitor-- Adds the Signal to the Janitor. ) → Signal&lt;Function,Arguments...&gt; Constructs a new Signal.  "},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal ,-- Existing RBXScriptSignal to wrap janitor?: Janitor-- Adds the Signal to the Janitor. ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   "},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Is","content":"&lt;/&gt; Signal.Is( value: unknown-- Object to check. ) → boolean-- true if the value is a Signal. Checks if the given value is a Signal.  "},{"title":"instanceof​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#instanceof","content":"&lt;/&gt; Signal.instanceof( value: unknown-- Object to check. ) → boolean-- true if the value is a Signal. A shorthand for Signal.Is.  "},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect( callback: (Arguments...) → ()-- The function you are connecting. ) → Connection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   "},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Once","content":"&lt;/&gt; Signal:Once( callback: (Arguments...) → ()-- The function you are connecting. ) → Connection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   "},{"title":"ConnectClassic​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#ConnectClassic","content":"since v2.0.0 &lt;/&gt; Signal:ConnectClassic( callback: (Arguments...) → ()-- The function you are connecting. ) → RBXScriptConnection  The exact same as Signal.Connect, but it returns an RBXScriptConnection instead.  "},{"title":"OnceClassic​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#OnceClassic","content":"since v2.0.0 &lt;/&gt; Signal:OnceClassic( callback: (Arguments...) → ()-- The function you are connecting. ) → RBXScriptConnection  The exact same as Signal.Once, but it returns an RBXScriptConnection instead.  "},{"title":"GetConnections​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#GetConnections","content":"&lt;/&gt; Signal:GetConnections() → {Connection} Gets all the connections in the signal.  "},{"title":"IsConnectedTo​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#IsConnectedTo","content":"since v1.0.1 &lt;/&gt; Signal:IsConnectedTo() → boolean Checks if there are any active connections in the signal.  "},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: Arguments...) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   "},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: Arguments...) → () Same as Signal.Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   "},{"title":"FireDeferredUnsafe​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#FireDeferredUnsafe","content":"since v2.0.0 &lt;/&gt; Signal:FireDeferredUnsafe(...: Arguments...) → () An &quot;unsafe&quot; version of Signal.FireDeferred that uses recycled threads to fire. Don't know if this will work the exact same, therefore it is unsafe. This should be faster than even Signal.Fire though, or around its performance level.  "},{"title":"FireBindable​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#FireBindable","content":"since v2.1.0 &lt;/&gt; Signal:FireBindable(...: Arguments...) → () This function mirrors how a BindableEvent would be fired given the current Workspace.SignalBehavior setting. If it is set to Enum.SignalBehavior.Deferred, it will use Signal.FireDeferred and if it is set to Enum.SignalBehavior.Immediate, it will use Signal.Fire.  "},{"title":"FireBindableUnsafe​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#FireBindableUnsafe","content":"since v2.1.0 &lt;/&gt; Signal:FireBindableUnsafe(...: Arguments...) → () This function mirrors how a BindableEvent would be fired given the current Workspace.SignalBehavior setting. If it is set to Enum.SignalBehavior.Deferred, it will use Signal.FireDeferredUnsafe and if it is set to Enum.SignalBehavior.Immediate, it will use Signal.Fire.  "},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...Arguments... Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, usingSignal.Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   "},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnect all handlers. Since we use a linked list it suffices to clear the reference to the head handler. signal:DisconnectAll()   "},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal and renders it completely unusable. Cleanups Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Signal.Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   "},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/BetterSignal/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce( callback: (Arguments...) → ()-- The function you are connecting. ) → Connection  "}]